## 1.Java基础

### 1.1 什么是Java中的垃圾回收机制？解释如何手动触发垃圾回收。

**Java中的垃圾回收机制是一种自动内存管理机制，用于自动回收不再使用的对象以释放内存。Java的垃圾回收器负责检测并清理不再被引用的对象，以确保内存的有效利用。**

垃圾回收是由Java虚拟机（JVM）的垃圾回收器自动触发的，但也可以通过手动方式进行触发。虽然手动触发垃圾回收通常不是推荐的做法，但在某些特定情况下可能会有用。

在Java中，可以使用`System.gc()`方法来请求运行垃圾回收。但请注意，这只是向JVM发送一个垃圾回收的建议，并不保证立即执行。

另外，可以使用`Runtime.getRuntime().gc()`方法来执行垃圾回收。这是`System.gc()`的等效方法，同样不保证立即执行。

需要注意的是，手动触发垃圾回收并不意味着立即释放所有不再使用的对象。垃圾回收的触发和执行仍然由JVM控制，而手动触发只是提供了一个建议。

总而言之，垃圾回收是Java自动管理内存的机制，可以通过`System.gc()`或`Runtime.getRuntime().gc()`方法手动触发，但并不能保证立即执行。在大多数情况下，应该依靠JVM的自动垃圾回收机制来管理内存。



### 1.2 解释Java中的线程和线程同步

**线程同步是一种用于控制多个线程访问共享资源的机制，以避免数据竞争和不确定性的结果。**

**Java提供了多种机制来实现线程同步，其中最常用的是使用`synchronized`关键字和`ReentrantLock`类。**这些机制可以用于创建临界区（也称为互斥区），在该区域中只允许一个线程访问共享资源。

通过`synchronized`关键字，可以将方法或关键代码块标记为同步的。当一个线程进入同步区域时，它会获取锁，并执行相应的操作。其他线程在同步区域外等待，直到锁被释放。这确保了同一时间只有一个线程可以执行同步操作。

另外，`ReentrantLock`类提供了显示锁的实现，以更灵活和细粒度地控制线程同步。它提供了与`synchronized`关键字类似的功能，但具有更多扩展性和可操作性，例如可重入锁、公平性选择等。

线程同步的目的是保证正确的访问和修改共享资源，以避免数据竞争和一致性问题。正确地使用线程同步机制可以确保多线程程序的可靠性和正确性。



### 1.3 什么是Java中的序列化和反序列化？为什么要使用它们？

在Java中，序列化（Serialization）指的是将对象转换为字节序列的过程，而反序列化（Deserialization）则指的是将字节序列转换为对象的过程。

1. 对象持久化：通过将对象序列化后保存到文件或数据库中，我们可以实现对象的持久化，即使在应用程序重启或传输到其他环境时仍然能够保持对象的状态。
2. 对象复制：通过将对象序列化并再次反序列化，可以创建对象的深拷贝，从而在一些需要复制对象的场景中提供了便利。

 

### 1.4 解释Java中的IO操作。比较字节流和字符流的区别。

在Java中，IO（Input/Output）操作用于处理与外部设备（如文件、网络连接、控制台等）的数据输入和输出。Java提供了字节流和字符流两种类型的IO操作，它们有以下区别：

**字节流（Byte Stream）**

- 字节流以字节为单位进行读取和写入操作。
- 字节流适用于处理二进制数据（如图像、音频、视频等）和字节流传输。
- 字节流通常以`InputStream`和`OutputStream`为基础类。
- 典型的字节流类有`FileInputStream`、`FileOutputStream`、`BufferedInputStream`、`BufferedOutputStream`等。

**字符流（Character Stream）**

- 字符流以字符为单位进行读取和写入操作，字符流会将字节转换为字符。
- 字符流适用于处理文本数据，能够更好地处理字符编码和字符集。
- 字符流通常以`Reader`和`Writer`为基础类。
- 典型的字符流类有`FileReader`、`FileWriter`、`BufferedReader`、`BufferedWriter`等。

区别：

1. 数据单位：字节流以字节为单位进行读取和写入，字符流以字符为单位进行读取和写入。字符流更适用于处理文本数据。
2. 数据处理：字节流适用于处理二进制数据和字节流传输，而字符流更擅长处理字符编码和字符集。
3. 编程方式：字节流通常是比较底层的操作，适用于底层IO；字符流封装了字节流，提供了更高层次、更方便的IO操作接口。
4. 转换机制：字符流在内部会进行字节与字符的转换，需要考虑字符编码和字符集；字节流没有进行字符转换的过程。

一般来说，如果要处理的数据是文本数据，或者需要考虑字符编码和字符集的情况下，推荐使用字符流进行IO操作。如果要处理的数据是二进制数据，或者需要进行底层IO操作，可以使用字节流进行IO操作。同时，可以通过缓冲流来提高IO性能，减少IO操作的次数。



### 1.5 双亲委派原则

它的工作流程是：当一个类加载器收到类加载任务，会先交给其父类加载器区完成，因此最终加载任务都会传递到顶层的 启动类加载器，只有当父类加载器无法完成加载任务时，才会回到子类加载器区尝试执行加载任务。



### 1.6 Java的面向对象

1. **封装（Encapsulation）**：封装是将数据和对数据的操作封装在一个对象中，通过定义类的属性（字段）和方法来实现。对象的内部细节对外部是不可见的，只能通过对象提供的公共接口来访问和操作数据。
2. **继承（Inheritance）**：继承是一种机制，让一个类可以基于另一个类来扩展和复用代码。通过继承，子类可以继承父类的属性和方法，并且可以添加新的属性和方法，实现代码的继承和扩展。
3. **多态（Polymorphism）**：多态是指一个对象可以具有多种形态，同一个方法可以在不同的对象上产生不同的行为。在Java中，多态通过方法的重写和重载来实现，使得程序代码更加灵活和可扩展。
4. **抽象（Abstraction）**：抽象是一种对现实问题的简化和概括，将问题的重要特征提取出来形成抽象类或接口，通过继承和实现来实现具体的功能。抽象可以帮助开发者更好地理解和设计程序的结构，提高代码的可读性和可维护性。



### 1.7 有关字节流到字符流的桥接器

​	有些标准输入输出设备被定义成了字节流，我们需要把他们转换为字符流，这里就可以使用桥接器，

​	如下：

​	BufferedReader br=new BufferedReader(new FIleReader("hello.txt")); //指向文本的字符输入流



### 1.8 反射的作用及原理

​	JAVA反射机制是在**运行状态中**对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。



### 1.9 说说什么是fail-fast

fail-fast是Java Collection中的一种错误机制。当多个线程同时对同一个集合进行操作时，就可能产生fail-fast事件。



### 1.10 面向对象的软件设计有哪些设计原则？

1. 单一职责原则（一个类只应有一个职责，使应用的设计更清晰）
2. 开闭原则（对扩展开放，对修改关闭）
3. 里氏替换原则（一个类的子类应该能够完全替代它的父类）
4. 迪米特原则（一个对象应该减少对象之间的依赖关系）
5. 依赖倒置原则（高层模块不应依赖于底层模块，两者都依赖于抽象）
6. 接口隔离原则（一个类不应该强制他依赖的它不使用的方法）



### 1.11 switch支持的类型

Java中switch支持byte,char,short,int及对应包装类，本质上还是支持整型基本类型，因为Java虚拟机的tableSwitch命令和lookupSwitch命令只能作用与int类型

jdk1.5之后支持ENUM(枚举),是通过内部给枚举编号实现的

jdk1.7之后支持String，是通过hashcode实现的，但不允许为null



### 1.12 简单算法

* 二分查找
* 选择排序
* 冒泡排序



### 1.13 4种常用线程池

1. FixedThreadPool（固定线程池）
2. CacheTHreadPool（缓存线程池）
3. ScheduleThreadPool（定时任务线程池）
4. SingleThreadExecutor（单线程池）



## 2.Mysql

### 2.1 什么是索引

数据库索引是一种用于提高数据库查询性能的数据结构。它类似于书籍的目录，通过创建对数据库表的特定列或列组合的索引，可以快速定位和访问存储在数据库中的数据行。索引可以加速数据检索操作，减少查询的执行时间。

## 3.Mybatis

### 3.1 Mybatis分页原理

​	Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。



## 4.Spring

### 4.1 SpringBoot的优点

1. 简化配置
2. 快速开发
3. 内嵌容器
4. 自动化的管理
5. 微服务的支持
6. 强大的生态系统
7. 监控和管理



### 4.2 BeanFactory和FactoryBean的作用

- **BeanFactory**：BeanFactory是Spring框架的核心接口之一，它是工厂模式的实现，用于管理和获取Bean对象。它负责创建、配置、装配和管理Bean的实例。

  - ​	功能：
    1. **Bean的实例化和装配**：BeanFactory负责根据Bean的定义信息创建Bean实例并将其装配到相应的属性中
    2. **生命周期管理**：BeanFactory负责Bean的生命周期：创建、初始化和销毁
    3. **依赖注入**：BeanFactory将Bean之间的依赖关系通过依赖注入的方式解析和注入
    4. **配置元数据的管理**：BeanFactory负责Bean的配置元数据，包括XML配置文件、注解配置等

- **FactoryBean**：FactoryBean是一个特殊的Bean，用于创建其他Bean的实例。它允许开发人员在Bean的创建过程中插入自定义的逻辑。

  - 具体实现类：FactoryBean接口的两个实现类：

    ```Java
    org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean
    org.springframework.beans.factory.config.AbstractFactoryBean
    ```

  - 功能：

    1. **创建复杂对象**：FactoryBean可以创建复杂对象，如数据库连接池、远程服务代理等，隐藏了创建的细节
    2. **懒加载**：FactoryBean支持懒加载，当需要使用Bean的时候才创建实例，可以提高性能
    3. **创建代理对象**：FactoryBean可以用于创建代理对象，如AOP代理

**总结：BeanFactory是Spring容器的核心接口，负责创建和管理Bean实例；FactoryBean是一个特殊的Bean，用于创建其他Bean实例，并提供了懒加载和代理等功能。**



### 4.3 单例模式和原型模式

在SpringFrameWork中，Bean的创建有两种范围：Singleton和Prototype

1. Singleton范围（单例）

   在Singleton范围中，Spring容器会确保在整个应用程序上下文中，对于每种Bean定义，只创建一个Bean实例。这意味着每次请求同一个Bean时，容器都会返回同一个实例。Singleton是Spring中的默认范围。

   > 当Spring容器启动时，它会扫描应用程序上下文中的所有Bean定义。
   > 对于每个被标记为Singleton的Bean，容器会在启动时创建一个实例。
   > 当应用程序请求一个Singleton Bean时，容器将返回该实例的引用。
   > 如果在应用程序上下文中请求相同的Singleton Bean多次，容器始终返回相同的实例。
   > 这种方式适用于那些在整个应用程序生命周期中不会改变状态的Bean，例如配置类、服务类、数据源等。

2. Prototype范围（原型）

   在Prototype范围中，Spring容器每次请求一个Bean时都会创建一个新的实例。这意味着在应用程序中，每次获取该Bean时，都会得到一个不同的实例。

   > 当Spring容器启动时，它会扫描应用程序上下文中的所有Bean定义。
   > 对于每个被标记为Prototype的Bean，容器不会在启动时创建实例。
   > 当应用程序请求一个Prototype Bean时，容器将为该请求创建一个全新的实例。
   > 如果在应用程序上下文中多次请求相同的Prototype Bean，容器每次都返回一个新的实例。
   > 这种方式适用于那些在应用程序运行过程中可能改变状态的Bean，例如托管会话、请求处理等。

**总结：Singleton范围的Bean在Spring容器启动时创建一个实例，并在整个应用程序运行过程中始终返回相同的实例。而Prototype范围的Bean在每次请求时创建新的实例。**



### 4.4 @Configuration 和 @Component 有何区别？

@Component 注解用于标记一个类为 Spring 的组件，表示它是一个被 Spring 管理的 Bean。通过 @Component 注解，我们可以将一个类交给 Spring 容器管理，从而享受 Spring 提供的依赖注入、AOP 等功能。

@Configuration 注解的作用是标记一个类为 Spring 的配置类。配置类用于定义 Spring 的配置信息，常见的配置内容包括定义 Bean、配置数据源、配置事务管理等。一般而言，配置类需要使用 @Configuration 注解进行标记，同时通过在方法上使用 @Bean 注解来定义 Bean。

**简而言之，@Component 注解用于标记一个类为 Spring 的组件，而 @Configuration 注解用于标记一个类为 Spring 的配置类。这两个注解在不同的场景下使用，但都是用于实现 IoC（Inversion of Control）和依赖注入功能的关键注解。**



### 4.5 SpringBean的生命周期

SpringBean 的生命周期可以分为以下四个阶段：

1. 实例化（Instantiation）：在这个阶段，Spring容器会根据配置信息实例化Bean对象。这可以通过构造函数实例化、工厂方法实例化或通过特定策略创建Bean对象。
2. 属性赋值（Population）：在这个阶段，Spring容器会将配置的属性值注入到Bean对象中。可以通过setter方法注入属性值，也可以通过注解或XML配置进行属性赋值。
3. 初始化（Initialization）：在这个阶段，Spring容器会调用Bean的初始化方法对Bean进行初始化操作。可以通过实现InitializingBean接口的afterPropertiesSet()方法、配置init-method方法或使用注解进行初始化。
4. 销毁（Destruction）：在容器关闭或Bean被移除时，Spring容器会调用Bean的销毁方法对Bean进行销毁操作。可以通过实现DisposableBean接口的destroy()方法、配置destroy-method方法或使用注解进行销毁。

需要注意的是，Bean的生命周期是由Spring容器管理的，容器在创建Bean时会按照上述生命周期顺序进行处理。
